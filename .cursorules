# Project Instructions

Use specification and guidelines as you build the app.

Write the complete code for every step. Do not get lazy.

Your goal is to completely finish whatever I ask for.

You will see <ai_context> tags in the code. These are context tags that you should use to help you understand the codebase.

## Overview

This is a Next.js SaaS starter template.

## Tech Stack

- Frontend: Next.js (App Router), Tailwind CSS, Shadcn/ui
- Backend: Postgres, Drizzle ORM, Server Actions
- Auth: Custom JWT-based authentication (using `jose`, `bcryptjs`, cookies)
- Payments: Stripe
- Deployment: Vercel (recommended)

## Project Structure

- `app/` - Next.js App Router containing route groups, pages, layouts, and API routes.
  - `(dashboard)/` - Route group for authenticated dashboard sections.
    - `dashboard/` - User settings and activity pages/layouts.
    - `pricing/` - Pricing page and related components.
    - `layout.tsx` - Main layout for authenticated areas (includes header).
    - `page.tsx` - Main landing/marketing page.
    - `terminal.tsx` - Animated terminal component for the landing page.
  - `(login)/` - Route group for authentication pages.
    - `sign-in/`, `sign-up/` - Pages for login/registration.
    - `actions.ts` - Server Actions related to authentication and user management.
    - `login.tsx` - Shared component for sign-in/sign-up forms.
  - `api/` - API routes (e.g., Stripe webhooks).
- `components/` - Shared React components.
  - `ui/` - UI components, likely generated by Shadcn/ui (Button, Card, Input, etc.).
- `lib/` - Core logic, utilities, and configurations.
  - `auth/` - Authentication logic (JWT, sessions, middleware helpers).
  - `db/` - Database configuration (Drizzle), schema, migrations, queries, and seeding.
  - `payments/` - Stripe integration logic (actions, client setup).
  - `utils.ts` - Utility functions (e.g., `cn` for class names).
- `public/` - Static assets (implicitly, contains `favicon.ico`).
- Configuration files (`.env.example`, `components.json`, `drizzle.config.ts`, `next.config.ts`, `package.json`, `postcss.config.mjs`, `tsconfig.json`).

## Rules

Follow these rules when building the app.

### General Rules

- Use `@` to import anything from the app unless otherwise specified (e.g., `@/components/ui/button`).
- Use kebab-case for all files and folders unless otherwise specified (e.g., `invite-team.tsx`).
- Don't update shadcn components directly in `components/ui/` unless otherwise specified. Modify them through extension or wrapping if needed.

#### Env Rules

- If you update environment variables, update the `.env.example` file.
- All environment variables should go in `.env`. *Note: The template uses `.env`, not `.env.local`, ensure consistency.*
- Do not expose sensitive environment variables to the frontend. Server-side variables (like `STRIPE_SECRET_KEY`, `POSTGRES_URL`, `AUTH_SECRET`) should only be accessed on the server (Server Components, Server Actions, API routes).
- You may import environment variables in server-side code (Server Actions, API routes, `lib` files used only on the server) by using `process.env.VARIABLE_NAME`.

#### Type Rules

Follow these rules when working with types.

- Types are often co-located with the modules they describe (e.g., DB types in `lib/db/schema.ts`, Action state types in `lib/auth/middleware.ts`). Create new type files in `lib/types/` if needed for broader types.
- If creating separate type files, name them like `example-types.ts`.
- Prefer interfaces over type aliases where appropriate, but use `type` for defining shapes like `ActionState`.
- If referring to DB types generated by Drizzle, import them directly from `@/lib/db/schema`, such as `User`, `NewUser`, `Team`.

An example of the `ActionState` type (defined in `lib/auth/middleware.ts`):

```ts
export type ActionState = {
  error?: string;
  success?: string;
  [key: string]: any; // Allows for additional return data if needed
};
```

### Frontend Rules

Follow these rules when working on the frontend.

It uses Next.js (App Router), Tailwind CSS, and Shadcn/ui components.

#### General Rules

- Use `lucide-react` for icons.
- Use the `useUser` hook from `@/lib/auth` within a `UserProvider` to access user state in client components.

#### Components

- Use standard HTML tags (div, section, button, etc.) as appropriate for semantics.
- Separate the main parts of a component's JSX with an extra blank line for visual spacing.
- Always tag a component file with either `"use server"` or `"use client"` at the top, including layouts and pages, depending on its needs.

##### Organization

- Name component files using kebab-case (e.g., `invite-team.tsx`).
- Put shared UI components (especially those from Shadcn/ui) in `/components/ui/`.
- Route-specific components can be placed directly within their respective route directories (e.g., `app/(dashboard)/dashboard/invite-team.tsx`). Consider using a `_components` subfolder within the route if the number of components grows.

##### Data Fetching & Mutation

- Prefer fetching initial data in Server Components (Pages or Layouts) and passing it down as props to Client Components. Use functions from `lib/db/queries.ts`.
- Use Server Actions (defined in files like `app/(login)/actions.ts` or `lib/payments/actions.ts`) to mutate data.
- Server Actions can be invoked from Client Components using the `action` prop on forms or hooks like `useActionState`.

##### Server Components

- Use `"use server"` at the top of the file if the component itself performs server-only operations (though often data fetching happens in Pages/Layouts which are Server Components by default).
- Implement Suspense for asynchronous data fetching in Pages/Layouts to show loading states (though the current examples don't heavily rely on Suspense boundaries, preferring direct data fetching in async Server Components/Pages).
- If no asynchronous data fetching is required for a given Server Component/Page, you do not need to wrap its children in `<Suspense>`. You can return the final UI directly.
- If asynchronous fetching *is* required (e.g., in an `async function` Page or Layout), data fetching should occur directly within that async function. Suspense can be used higher up the tree or around specific async parts if needed.
- Server components cannot be directly imported and used *within* client components' render logic. Pass Server Components as `children` props to Client Components if necessary.

Example of a Server Page (fetching data):

```tsx
// app/(dashboard)/dashboard/page.tsx
import { redirect } from 'next/navigation';
import { Settings } from './settings'; // This might be a client component
import { getTeamForUser, getUser } from '@/lib/db/queries';

export default async function SettingsPage() {
  const user = await getUser(); // Fetch data directly

  if (!user) {
    redirect('/sign-in');
  }

  const teamData = await getTeamForUser(user.id); // Fetch data directly

  if (!teamData) {
    // Handle error appropriately, maybe redirect or show an error message component
    throw new Error('Team not found');
  }

  // Pass fetched data to the client component
  return <Settings teamData={teamData} />;
}
```

##### Client Components

- Use `"use client"` at the top of the file.
- Use React hooks (`useState`, `useEffect`, `useActionState`, etc.) for interactivity and state management.
- Client components receive initial data as props from parent Server Components.
- Invoke Server Actions for mutations using the `action` prop on `<form>` elements or programmatically with hooks like `useActionState` (often wrapped in `startTransition`).

Example of a Client Component using a Server Action:

```tsx
// app/(dashboard)/dashboard/general/page.tsx
'use client';

import { startTransition, useActionState } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
// ... other imports
import { useUser } from '@/lib/auth';
import { updateAccount } from '@/app/(login)/actions'; // Import Server Action

type ActionState = { // Define or import ActionState type
  error?: string;
  success?: string;
};

export default function GeneralPage() {
  const { user } = useUser();
  const [state, formAction, isPending] = useActionState<ActionState, FormData>(
    updateAccount, // Use the server action
    { error: '', success: '' }
  );

  const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    startTransition(() => {
      formAction(new FormData(event.currentTarget)); // Call the action
    });
  };

  return (
    <section>
      {/* ... form structure ... */}
      <form className="space-y-4" onSubmit={handleSubmit}>
        {/* ... inputs ... */}
        {state.error && <p className="text-red-500 text-sm">{state.error}</p>}
        {state.success && <p className="text-green-500 text-sm">{state.success}</p>}
        <Button type="submit" disabled={isPending}>
          {isPending ? 'Saving...' : 'Save Changes'}
        </Button>
      </form>
    </section>
  );
}

```

### Backend Rules

Follow these rules when working on the backend.

It uses Postgres, Drizzle ORM, and Server Actions.

#### General Rules

- Use `pnpm db:generate` to create migration files after making changes to `lib/db/schema.ts`.
- Use `pnpm db:migrate` to apply pending migrations to your database.
- Review generated migration SQL files in `lib/db/migrations/` before applying, but generally avoid manual edits unless correcting a generation issue.

#### Organization

##### Schemas

- Define all database schemas in `lib/db/schema.ts`.
- Export table definitions and inferred types (e.g., `User`, `NewUser`) from `lib/db/schema.ts`.
- Use Drizzle relations API within `lib/db/schema.ts` to define relationships between tables.
- If using a `userId`, define it as `userId: integer('user_id').notNull().references(() => users.id)`. Adjust type (`integer`) based on the referenced primary key (`users.id` is `serial` which maps to `integer`).
- Always include `createdAt` and `updatedAt` timestamp columns in tables where tracking creation/modification time is relevant. Use `.defaultNow()` and potentially `.$onUpdate(() => new Date())` for `updatedAt`.
- Ensure foreign key constraints use appropriate `onDelete` behavior (e.g., `"cascade"`, `"set null"`).
- Use Drizzle's `pgEnum` for columns with a fixed set of string values, defining the enum separately and referencing it in the column definition. The target template uses `varchar` with string literals for `role` and `status`; stick to that pattern or refactor to use `pgEnum` if preferred.

Example Schema Snippet (from `lib/db/schema.ts`):

```ts
import { pgTable, serial, varchar, text, timestamp, integer } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: varchar('name', { length: 100 }),
  email: varchar('email', { length: 255 }).notNull().unique(),
  passwordHash: text('password_hash').notNull(),
  role: varchar('role', { length: 20 }).notNull().default('member'), // Consider pgEnum here if desired
  createdAt: timestamp('created_at').notNull().defaultNow(),
  updatedAt: timestamp('updated_at').notNull().defaultNow(), // Add .$onUpdate(() => new Date()) if auto-update desired
  deletedAt: timestamp('deleted_at'),
});

// ... other tables ...

// Example Relation
export const usersRelations = relations(users, ({ many }) => ({
  teamMembers: many(teamMembers),
  // ... other relations
}));

// Export types
export type User = typeof users.$inferSelect;
export type NewUser = typeof users.$inferInsert;
// ... other types
```

##### Server Actions

- Place authentication and user/team management related Server Actions in `app/(login)/actions.ts`.
- Place payment-related Server Actions in `lib/payments/actions.ts`.
- For other domains, create new `actions.ts` files within relevant `lib/` subdirectories or `app/` route groups.
- Use the `validatedAction`, `validatedActionWithUser`, or `withTeam` wrappers from `lib/auth/middleware.ts` to handle validation (Zod) and user/team context retrieval.
- Actions wrapped with these helpers implicitly return a promise resolving to an `ActionState` object (`{ error?: string; success?: string; ... }`).
- Structure action logic clearly within the wrapper functions.
- **Date Handling:** When comparing or inserting date/timestamp values, ensure JavaScript `Date` objects are used or correctly formatted strings (like ISO strings via `.toISOString()`) are provided to Drizzle, matching the column type.

Example Action using `validatedActionWithUser`:

```ts
// app/(login)/actions.ts
'use server';

import { z } from 'zod';
import { db } from '@/lib/db/drizzle';
import { users } from '@/lib/db/schema';
import { eq } from 'drizzle-orm';
import { validatedActionWithUser } from '@/lib/auth/middleware';
// ... other imports

const updateAccountSchema = z.object({
  name: z.string().min(1, 'Name is required').max(100),
  email: z.string().email('Invalid email address'),
});

export const updateAccount = validatedActionWithUser(
  updateAccountSchema,
  async (data, _, user) => { // data is validated, user is authenticated user object
    const { name, email } = data;
    // ... (logActivity logic) ...

    try {
      await db.update(users)
        .set({ name, email }) // Drizzle handles updatedAt via schema default/onUpdate
        .where(eq(users.id, user.id));

      // ... (log activity) ...

      return { success: 'Account updated successfully.' };
    } catch (error) {
      console.error("Error updating account:", error);
      return { error: 'Failed to update account.' };
    }
  },
);

```

### Auth Rules

Follow these rules when working on auth.

It uses a custom JWT-based system with `jose`, `bcryptjs`, and cookies.

#### General Rules

- Authentication state is managed via the `UserProvider` context (`lib/auth/index.tsx`) on the client-side. Use the `useUser()` hook to access the current user in Client Components.
- Server-side authentication checks (in Server Actions, API Routes, Server Components) use the `getUser()` function from `lib/db/queries.ts`, which verifies the session cookie.
- Use the `validatedActionWithUser` and `withTeam` helper functions (`lib/auth/middleware.ts`) for Server Actions requiring authenticated users or team context.
- Session management (creation, verification, update) logic is in `lib/auth/session.ts`.
- Password hashing uses `bcryptjs`.
- Middleware (`middleware.ts`) handles redirecting unauthenticated users from protected routes and refreshing the session cookie.

### Payments Rules

Follow these rules when working on payments.

It uses Stripe.

#### General Rules

- Stripe client and core functions are in `lib/payments/stripe.ts`.
- Server Actions related to payments (e.g., creating checkout sessions, customer portal) are in `lib/payments/actions.ts`.
- API Routes (`app/api/stripe/...`) handle callbacks (like checkout success) and webhooks.
- Use environment variables for Stripe keys (`STRIPE_SECRET_KEY`, `STRIPE_WEBHOOK_SECRET`).

### Analytics Rules

- No specific analytics solution is integrated in this template. If adding one, create relevant rules here.

### Storage Rules

- No specific file storage solution (like Supabase Storage or S3) is integrated in this template. If adding one, create relevant rules here, potentially adapting the original Supabase Storage rules for the chosen provider.
